
- Recall that when an OS offers protection, it means that it will prohibit the green program will not be abled to modify the brown program's state, the os state or the storage (otherwise segfault most likely).
	- ![[Pasted image 20240905223431.png]]
- Again OS abstracts underlying hardware:
	- processor -> threads
	- memory -> address space
	- disks, ssds, .. -> files
	- networks -> sockets
	- machines -> processes
- Threads
	- Recall how instructions are run (from 61c):
		- ![[Pasted image 20240905233201.png]]
	- it suffices to consider threads as a virtualized version of the 61c processor
	- a thread is executing on a processor/core when it is resident in the processor registers:
	- a thread is suspended when its state is not loaded and another thread is in resident
- Illusion of Multiple Processors
	- assuming a single processor/core, how do we provide the illusion of multiple?
	- illusion:
		- ![[Pasted image 20240907032134.png]]
	- threads are virtual cores
		- ![[Pasted image 20240907032227.png]]
		- the content of a thread includes pc, stack pointer, registers
		- when running it is on the real actual core, when not it is saved in a chunk of memory called the thread control block (tcb)
			- what triggers the switch? timer, voluntary yield, I/O, other things later.
	- An alternate view - each thread also maintains its own stack, heap, static data, and code
		- ![[Pasted image 20240907033237.png]]
		 - the TCB holds contests of registers when the thread isn't running. for now the tcb's are held in the kernel. 
- Address Spaces: accessible addresses + state in them
	- 64 bit processor -> 2^64 addresses
	- ![[Pasted image 20240909041459.png]]
	- code segment: code, static: string constants, static vars, stack: local variables, heap: malloc
- assuming each thread can read/write memory an issue arises -> we can overwrite data of other threads (kinda risky)
	- simple multiplexing has no protection!
- OS must protect itself from user programs:
	- reliability (compromising OS should cause program to crash)
	- security (limit what threads can do)
	- privacy (limi each thread to the data it is allowed to access)
	- fairness (each thread should be limited to its appropriate share of system resources like CPU time, memory, I/O, etc.)
- it should also protect programs from one another
- simple protection: base and bound via relocating loader
	- loader places programs into memory and prepares them for execution
	- relocating loader example: imagine programmer writes program that uses memory addresses 0 through 999, and compiles it. then when program is loaded into memory, os decides to load the new program starting at memory address 1000 (since suppose 0 through 999 is already in use)
	- ![[Pasted image 20240909233058.png]]
- simple address translation with base and bound (hardware adder converts PC on the fly):
	- ![[Pasted image 20240909233947.png]]
- Process:
	- execution environment with address space and with 1+ threads
		- threads encapsulate concurrency
		- address space encapsulate protection
		- multi threads per process: parallelism (take advantage of hardware parallelism), concurrency (thread a deals with mouse movement, b deals other i/o, etc.)
- Dual Mode:
	- hardware provides kernel/supervisor mode and user mode:
		- operations like changing the page table pointer, disabling interrupts, ... are prohibited in user mode
		- 